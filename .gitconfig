[filter "lfs"]
    smudge = git-lfs smudge -- %f
    process = git-lfs filter-process
    required = true
    clean = git-lfs clean -- %f
[core] 
    # editor = "" --wait
[user]
    name = MacbookPro-Nia
    email = sh563295875@163.com
[alias]
    co = checkout
    br = branch
    ci = commit
    # ci -am "message" add与commit合并指令（只对已经index的文件有效）如果是工作区新增的文件必须要先add
    # git status -u untracked的文件默认只会输出到他的所处的文件夹，u参数可以把所有全路径文件名输出到控制台
    st = status -u
    last = log -1 HEAD
    lg = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit
    unstage = reset HEAD --
    # 比较index files和commit的差别
    dc = diff --cached
    # 比较工作区中和最新一次commit的差别
    dh = diff HEAD
    # 比较工作区与index files中的差别
    d = diff
    # 显示两次commit之间差异的文件列表,包含文件的全路径名
    ds = diff --stat=10000
    # 修改上一次的提交内容
    cia = commit --amend
    # 不以快进的形式合并别的分支，保留别的分支信息
    mn = merge --no-ff
    # 将别的分支上的多个commit合并为一个commit，并且把修改后内容add到暂存区，tip：没有commit，需要我们diff head 看看修改了哪里，最后自己把这个合并后的内容进行commit
    ms = merge --squash 
    # git cherry-pick <commitId> ...（将其他分支的一些commit应用在本分支，tip:最好从左往右写旧的到新的commitId，否则如果直接写一个最新的commitId有可能会出现conflict
    # 拉取远程分支别人的提交到我们即将要提交内容之前，让分支保持一条直线
    # git pull --rebase
    # git fetch origin master:tmp 只拉取不合并
    # git pull 等价于git fetch 和 git merge 会自动合并，并创建一个合并的commit
    # git pull --rebase 等价于 git pull 和 git rebase
    # git stash pop --index // 不加index参数是默认不将暂存取的内容回复的，都是直接回复到工作区
    # git reset // 不加--hard参数不会把工作空间的修改还原只会把暂存区的修改还原
[merge]
    tool = BeyondCompare4
[mergetool "BeyondCompare4"]
    # path =
    # cmd = 
[diff]
    guitool = beyondcompare4
[difftool "beyondcompare4"]
    # path = 
    # cmd = 
